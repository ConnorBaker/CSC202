 % Author: Connor Baker
% Date Created: November 16, 2016
% Last Edited: November 28, 2016
% Version: 0.4a

\documentclass[12pt]{article}
% Import Packages
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{enumitem}
\usepackage{array}
\usepackage{gensymb}
\usepackage{caption}
\usepackage{tocloft}
\usepackage{minted}
%\usepackage[cache=false]{minted}
\usepackage{graphicx}
\graphicspath{{images/}}
\usepackage[export]{adjustbox}
\usepackage{subcaption}
\usepackage[left=1.5in,right=1.5in,top=1.5in,bottom=1.5in]{geometry}

\begin{document}
% Creates a title page with content centered vertically/horizontally
\null
\nointerlineskip 
\vfill
\let \snewpage \newpage
\let \newpage \relax
    \title{groupproject: matrices}
    \author{Connor Baker\\Rae Bouldin}
    \date{November 28, 2016\\Version 0.4a}
\maketitle
\let \newpage \snewpage
\vfill
\thispagestyle{empty}



\newpage % New page



% Create the table of contents formatted with dotted lines and roman page numbering
\makeatletter
\pagenumbering{roman}
\makeatother
\tableofcontents

% End the table of contents and reset page numbering to arabic
\clearpage
\pagenumbering{arabic}

% Create the Summary of Problem Specification section
\begin{center}
\section{Summary of Problem Specification}
\end{center}
\subsection{Abstract}
Write a program that reads two $3\times3$ matrices from file and computes the sum and product of the two matrices. Then, find the transpose, cofactor matrix, and determinant of the two resultant matrices. Then, find the inverse of the first matrix, and multiply it by the the first column of the second matrix. Finally, compute the standard deviation of the diagonal elements of the two inputted matrices.
All input and output should be stored in files.



\newpage % New page



% Create the Formulae section
\begin{center}
\section{Formulae}
\end{center}
\subsection{Determinant}
The determinant of a $3\times3$ matrix is most readily computed by row reducing to a triangular matrix, and taking the product of the main diagonal. However, failing that, one can calculate the determinant by doing cofactor expansion. Though a horribly inefficient algorithm for larger matrices, it gets the job done. For a $3\times3$ matrix $A$, its determinant, det($A$), can be computed using placeholder values as follows:
\[
A =
\begin{bmatrix}
    a & b & c \\
    d & e & f \\
    g & h & i
\end{bmatrix}
\]
\begin{equation*}
\text{det($A$)} =
  a\begin{vmatrix}
  e & f\\
  h & i
  \end{vmatrix}  
  -b\begin{vmatrix}
  d & f\\
  g & i
  \end{vmatrix}  
  +c\begin{vmatrix}
  d & e\\
  g & h
  \end{vmatrix}\\\\
\end{equation*}
\begin{equation}
\text{det($A$)} =
a(ei-fh)-b(di-fg)+c(dh-eg)
\end{equation}

As such, we can calculate the determinant of a $3\times3$ matrix by expanding across the top row. This yields the approach implemented in \texttt{determinantOfMatrix()}, detailed in Section 4.3.

\subsection{Transpose}
Using the same approach as above, we can easily compute the transpose of a matrix. It involves creating a matrix filled with placeholder values, calculating the transpose matrix by hand, and tracking the positions of the elements in the matrix. For a $3\times3$ matrix $A$, let its transpose be $A^T$. Then:
\[
A =
\begin{bmatrix}
    a & b & c \\
    d & e & f \\
    g & h & i
\end{bmatrix}
\]
\begin{equation}
A^T =
    \begin{bmatrix}
    a & d & g \\
    b & e & h \\
    c & f & i
\end{bmatrix}
\end{equation}
This yields the approach implemented in \texttt{transposeOfMatrix()}, detailed in Section 4.4.

\subsection{Matrix Addition}
The approach used to create an algorithm for matrix addition is similar to that used above in finding the determinant. We again create matrices full of placeholder values, and track them as we perform the operation. For two $3\times3$ matrices $A$ and $B$, the process is as follows:
\[
A =
\begin{bmatrix}
    a & b & c \\
    d & e & f \\
    g & h & i
\end{bmatrix}
\qquad
B = 
\begin{bmatrix}
    j & k & l \\
    m & n & o \\
    p & q & r
\end{bmatrix}
\]
\begin{equation}
    A+B = 
    \begin{bmatrix}
    a + j & b + k & c + l \\
    d + m & e + n & f + o \\
    g + p & h + q & i + r
    \end{bmatrix}
\end{equation}
This yields the approach implemented in \texttt{sumOfMatrices()}, detailed in Section 4.5.

\subsection{Matrix Multiplication}
The approach used to create an algorithm for matrix multiplication is similar to that used above in finding the determinant. We again create matrices full of placeholder values, and track them as we perform the operation. For two $3\times3$ matrices $A$ and $B$, the process is as follows:
\[
A =
\begin{bmatrix}
    a & b & c \\
    d & e & f \\
    g & h & i
\end{bmatrix}
\qquad
B = 
\begin{bmatrix}
    j & k & l \\
    m & n & o \\
    p & q & r
\end{bmatrix}
\]
\begin{equation}
    AB = 
    \begin{bmatrix}
    a j + b m + c p & a k + b n + c q & a l + b o + c r \\
    d j + e m + f p & d k + e n + f q & d l + e o + f r \\
    g j + h m + i p & g k + h n + i q & g l + h o + i r
    \end{bmatrix}
\end{equation}
This yields the approach implemented in \texttt{productOfMatrices()}, detailed in Section 4.6.

\subsection{Cofactor Matrix}
The approach used to calculate the cofactor matrix is identical to what was done above. It involves creating a matrix filled with placeholder values, calculating the cofactor matrix by hand, and tracking the positions of the elements in the matrix. For a $3\times3$ matrix $C$, let its cofactor matrix be $C'$. Then:
\[
C =
\begin{bmatrix}
    a & b & c \\
    d & e & f \\
    g & h & i
\end{bmatrix}
\]
\[
C' =
\begin{bmatrix}
    % First row of cofactor matrix
    +\begin{vmatrix}
    e & f\\
    h & i
    \end{vmatrix} & 
    -\begin{vmatrix}
    d & f\\
    g & i
    \end{vmatrix} & 
    +\begin{vmatrix}
    d & e\\
    g & h
    \end{vmatrix}\\\\
    
    % Second row of cofactor matrix
    -\begin{vmatrix}
    b & c\\
    h & i
    \end{vmatrix} & 
    +\begin{vmatrix}
    a & c\\
    g & a
    \end{vmatrix} & 
    -\begin{vmatrix}
    a & b\\
    g & h
    \end{vmatrix}\\\\
    
    % Third row of cofactor matrix
    +\begin{vmatrix}
    b & c\\
    e & f
    \end{vmatrix} & 
    -\begin{vmatrix}
    a & c\\
    d & f
    \end{vmatrix} & 
    +\begin{vmatrix}
    a & b\\
    d & e
    \end{vmatrix}
\end{bmatrix}
\]
\begin{equation}
C' =
    \begin{bmatrix}
    e i - f h & f g - d i & d h - e g \\
    c h - b i & a i - c g & b g - a h \\
    b f - c e & c d - a f & a e - b d
\end{bmatrix}
\end{equation}
This yields the approach implemented in \texttt{cofactorOfMatrix()}, detailed in Section 4.7.

\subsection{Inverse of a Matrix}
The inverse of a matrix $A$, denoted $A^{-1}$ can be calculated as follows:
\begin{equation}
    A^{-1} = \frac{1}{\text{det($A$)}} * A^T
\end{equation}
Which is very doable using Equations (1) and (2). This approach is used in \texttt{inverseOfMatrix()}, detailed in Section 4.8.



\newpage % New page



% Create the Explanation of Main Class section
\begin{center}
\section{\texttt{Main.class}}
\end{center}



\newpage % New page



% Create the Explanation of Matrix Class section
\begin{center}
\section{\texttt{Matrix.class}}
\end{center}

\subsection{\texttt{Matrix()}}
\begin{minted}{java}
public Matrix() throws IOException
public Matrix(String filename) throws IOException
\end{minted}
\texttt{Matrix()} is the constructor. It is overloaded. The no-arg constructor reads from the default file of \texttt{matrix1.txt}. The argumented constructor, \texttt{Matrix(String filename)} accepts a file name (or path) in the form of a string.
\par Every \texttt{Matrix} object has four matrices (three two-dimensional arrays of type \texttt{int}, and one of type \texttt{double}, being the matrix read from file by \texttt{readMatrixFromFile()}, the transpose, the cofactor, and inverse matrices respectively). They also have an \texttt{int} that holds the determinant.
\par Both the no-arg and argumented \texttt{Matrix()} constructor call \texttt{readMatrixFromFile()}, the only difference being that the argumented constructor passes in the location of the file to read the matrix from.

\subsection{\texttt{readMatrixFromFile()}}
\begin{minted}{java}
public void readMatrixFromFile() throws IOException
\end{minted}
The method \texttt{readMatrixFromFile()} reads a two-dimensional array of integers from file. This method does not accept arguments. This method is called from the \texttt{Matrix()} constructor described above. The file to read from is passed in via the \texttt{Matrix()} constructor.

\subsection{\texttt{determinantOfMatrix()}}
\begin{minted}[breaklines]{java}
public static void determinantOfMatrix(int a[][])
public static void determinantOfMatrix(int a[][], String filename) throws IOException
\end{minted}
Using Equation (1) from Section 2.1, this method calculates the determinant of a matrix. \texttt{determinantOfMatrix()} is overloaded. Both methods accept a two-dimensional array of \texttt{int} as input, with the second of the two accepting a \texttt{String} holding the filename or path to write the output matrix to. This is accomplished by calling the \texttt{print()} method.

\subsection{\texttt{transposeOfMatrix()}}
\begin{minted}[breaklines]{java}
public static void transposeOfMatrix(int a[][])
public static void transposeOfMatrix(int a[][], String filename) throws IOException
\end{minted}
Using Equation (2) from Section 2.2, this method calculates the transpose of a matrix. \texttt{transposeOfMatrix()} is overloaded. Both methods accept a two-dimensional array of \texttt{int} as input, with the second of the two accepting a \texttt{String} holding the filename and or path to write the output matrix to. This is accomplished by calling the \texttt{print()} method.

\subsection{\texttt{sumOfMatrices()}}
\begin{minted}[breaklines]{java}
public static void sumOfMatrices(int a[][], int b[][], String filename) throws IOException
\end{minted}
Using Equation (3) from Section 2.3, this method calculates the sum of two matrices. The sum is written to a file passed in through the method signature. This is accomplished by calling the \texttt{print()} method.

\subsection{\texttt{productofMatrices()}}
\begin{minted}[breaklines]{java}
public static void productOfMatrices(int a[][], int b[][], String filename) throws IOException
\end{minted}
Using Equation (4) from Section 2.4, this method calculates the product of two matrices. The sum is written to a file passed in through the method signature. This is accomplished by calling the \texttt{print()} method.

\subsection{\texttt{cofactorOfMatrix()}}
\begin{minted}[breaklines]{java}
public static void cofactorOfMatrix(int a[][])
public static void cofactorOfMatrix(int a[][], String filename) throws IOException
\end{minted}
Using Equation (5) from Section 2.5, this method calculates the cofactor matrix of a matrix. texttt{cofactorOfMatrix()} is overloaded. Both methods accept a two-dimensional array of \texttt{int} as input, with the second of the two accepting a \texttt{String} holding the filename and or path to write the output matrix to. This is accomplished by calling the \texttt{print()} method.

\subsection{\texttt{inverseOfMatrix()}}
\begin{minted}[breaklines]{java}
public static void inverseOfMatrix() throws IOException
public static void inverseOfMatrix(String filename) throws IOException
\end{minted}
Using Equation (6) from Section 2.6, this method calculates the inverse of a matrix (in part by using \texttt{determinantOfMatrix} and \texttt{transposeOfMatrix}) \texttt{inverseOfMatrix()} is overloaded. Both methods accept a two-dimensional array of \texttt{int} as input, with the second of the two accepting a \texttt{String} holding the filename and or path to write the output matrix to. This is accomplished by calling the \texttt{print()} method.

\subsection{\texttt{print()}}
\begin{minted}[breaklines]{java}
public static void print(int a[][], String console) throws IOException
public static void print(int a[][], String console, String filename) throws IOException
public static void print(double a[][], String console) throws IOException
public static void print(double a[][], String console, String filename) throws IOException
\end{minted}
The \texttt{print()} method is overloaded. It accepts two-dimensional arrays of either type \texttt{int} or \texttt{double}, and prints either to console, or console and file/a path passed in to the method.
\par The \texttt{print()} method's purpose is limited to printing to console the type of operation that was performed, and then calling and passing the arguments on to either (or both) \texttt{printMatrixToConsole()} and \texttt{printMatrixToFile()}, described in detail below.

\subsection{\texttt{printMatrixToConsole()}}
\begin{minted}[breaklines]{java}
public static void printMatrixToConsole(int a[][])
public static void printMatrixToConsole(double a[][])
\end{minted}
The \texttt{printMatrixToConsole()} method consists of a \texttt{for} loop and a \texttt{System.out.println} holding a row of our $3\times3$ matrix (the two-dimensional array). It uses the speedup trick described in Section 5.1.

\subsection{\texttt{printMatrixToFile()}}
\begin{minted}[breaklines]{java}
public static void printMatrixToFile(int a[][], String filename) throws IOException
public static void printMatrixToFile(double a[][], String filename) throws IOException
\end{minted}
The \texttt{printMatrixToFile()} method consists of output streams (a \texttt{FileWriter}, \texttt{BufferedWriter}, and a \texttt{PrintWriter}) \texttt{for} loop and a \texttt{System.out.println} holding a row of our $3\times3$ matrix (the two-dimensional array). It uses the speedup trick described in Section 5.1.

\subsection{\texttt{printIntegerToFile()}}
\begin{minted}[breaklines]{java}
public static void printIntegerToFile(int a, String filename) throws IOException
\end{minted}
The \texttt{printMatrixToFile()} method consists of output streams (a \texttt{FileWriter}, \texttt{BufferedWriter}, and a \texttt{PrintWriter}) and simply prints to file the integer passed in through the method signature.



\newpage % New page



% Create the Notes section
\begin{center}
\section{Notes}
\end{center}
\subsection{A Note About the Methods}
By tailoring our methods for the specific order of matrix that we operate on ($3\times3$), we eliminate the need for method calls (specifically \texttt{matrix.length}), as well as the need for nested \texttt{for} loops. In this case, we should observe a speedup of 900\% (as the compiler does not unroll loops, we are effectively doing one ninth of the iterations that we would normally do) in all methods that process arrays.



\newpage % New page



% Create the References section
\begin{center}
\section*{References}
\addcontentsline{toc}{section}{References}
\end{center}
http://download.java.net/java/jdk9/docs/api/
\end{document}